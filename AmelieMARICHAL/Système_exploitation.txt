	Système d’Exploitation
SSH : Secure Shell
- Web : 80
- ftp : 21
- smtp
- pop
- s(web) secure : 443
Système de pointage de ressources unique
Apache : serveur web 
Structure client-serveur : 
Fichier de configuration pour accepter une seule adresse IP (127.0.0.1 ou localhost).
Le daemon fonctionne en tant que serveur spam et attend les requêtes de notre serveur mail qui fonctionne en tant que client. Le démon applique un statut « spam » aux mails concernés qui est catégorisé par le serveur mail.
Un mail est un fichier source, ce sera toujours du texte brut. En tant qu’administrateur on utilise des outils qui manipule des textes bruts et pour aller chercher des éléments rapidement. L’interface graphique parle en ligne de commande. 
SaaS : Cloud : Manière d’accéder à un service sur Internet : Moins de données sur les machines, plus de données sur les serveurs.
Internet : années 90 ; premier service d’internet : au début des années 70
Software as a Service : On externalise les logiciels (GoogleDoc)
Hébergement :
- mutualisé : on « mutualise » les ressources du serveur. Une seule machine répartit la charge pour plusieurs sites Internet
o A (serveur/daemon)/var/www/siteweb1
* Siteweb2
- dédié : une machine pour un site Internet (« root »)
- virtualisé : faire virtuellement tourner un système d’exploitation sur un autre (virtual box), administrateur de notre machine mais les ressources sont partagées entre plusieurs machines virtuelles
PaaS : Platform as a Service : on n’externalise plus seulement des données comme SaaS, mais on externalise l’ensemble des services dont on a besoin pour créer une plateforme. Ex : OpenShift
IaaS : Infrastructure as a Service. Ex : Amazon


Logiciels libres : 
- modifiable
- opensource
- copyright (date de 1969, date à laquelle le gouvernement a proclamé l’ « Unbundling Act », pour qu’IBM n’ait pas le monopole sur le logiciel et le hardware, faisant que les deux devaient être vendus séparément)
- droits d’auteur (donne à l’utilisateur le droit de modifier le logiciel, de tout redistribuer ainsi que le droit de vendre le logiciel)
ex : Linux, openoffice, firefox, thunderbird, notepad++, vlc
code source compilé <> interprété
Création de la Free Software Foundation (85) et de GNU : GNU is Not Unix (GNU : ensemble des logiciels qui font fonctionner le système d’exploitation), formé de l’association et de la licence GPL : GNU Public Licence
GNU = début du logiciel libre
Linux = On a toujours une seule racine comparé à Windows (C:\)
Une distribution est un écosystème dans lequel il y a le système d’exploitation, couche logicielle de base pour permettre l’affichage graphique. Au cœur du SE, il y aura le noyau, gérant la carte graphique. Autour du SE, il y aura des outils. 
Debian : Deborah + Ian, couple de développeurs
Installer soit Ubuntu, Fedora, LinuxMint, ArchLinux ou Debian sous Virtual Box pour le 4 avril 
Créer une clef public avec le programme ssh-keygen
Créer un compte openshift.com (OS) : uploader votre clef public sur OS
Créer un compte sur github.com : uploader clef public sur GH
Bastien.Guerry@free.fr : envoyer un mail avec nom et prénom
Droit d’auteur : distinction entre le droit moral (intégrité de l’œuvre) et le droit patrimonial (cession d’argent), en France. Aux US, les deux sont regroupés dans ce qu’on appelle le « Copyright ». 
MacOSX : Provient de (Free) BSD (qui est la même chose que GNU Linux ou quasiment qui s’inspire d’Unix), qui est la licence la plus proche du domaine public, qui permet de faire des œuvres dérivées sans avoir la restriction de faire des logiciels libres lorsque l’on reprend son code. 
Unix : différence entre : 
- (Free) BSD (Ouest) : Berkley Software Development : liberté totale -> MacOSX
- GNU/Linux : Est : restrictif. En 1991, Linus Torvald créé un noyau pour faire fonctionner Les outils GNU sur sa machine. 
SSH / Crypto et Git 
Chiffrements symétrique et asymétrique : 2 clefs différentes, publique et privée
Clef publique : boîte qui permet aux gens d’envoyer des messages
Clef privée : gardée sur sa machine 
Lorsque l’on est sur sa machine, on est dans un « shell ». Il donne un ensemble de commandes disponibles, comme « echo » qui fait partie de l’interpréteur Shell. Il y a d’autres interpréteurs comme Bash (Born again shell), Trsh.
Si on donne notre clef publique à un serveur distant, il nous connaît donc il va pouvoir chiffrer les transactions via la clef publique. Dans cette transaction, on aura la clef publique du serveur qui nous permettra alors d’envoyer aussi des éléments. 
/home/user_dist/.ssh/authorized_keys/ Dans ce répertoire, il y a notre clef publique et d’autres.
Gestionnaire de versions : CVS, Git, Subversion, mercurial, Tortoise SVN
Forge : Google Code, Github, BitBucket, Gitorious : pouvoir sauvegarder des informations de version sur le web
Il y a un dépôt central pour l’ensemble des modifications comme dans CVS, l’usage de Git se fait de la même façon avec quelques différences. Les personnes clonent le dépôt, on récupère alors tous les fichiers de ce dépôt plus tous ceux qui sont sur le répertoire.git. Clone permet de créer un miroir sur notre ordinateur. Le fait de commit permet de créer une version en local et Push permet de mettre sur le dépôt. 
Pour créer son dépôt : ‘’git init’’
		‘’git add fichier.txt’’
		‘’git commit’’ (pour créer une version) + ‘’ -m « message »’’ (ajouter un message)
Tout est un fichier qui est du texte.
mkdir isep_tmp : creation d’un repository temporaire
cd isep_tmp : aller à celui-ci
isep_tmp% mkdir
….
isep_tmp/isepse2014% git init : création du repository
isep_tmp/isepse2014% ls –l : regarder s’il y a des fichiers dessus
isep_tmp/isepse2014% ls –la
isep_tmp/isepse2014% git add empty.txt
isep_tmp/isepse2014% git status
…git add * : permet d’ajouter tous les fichiers 
…git commit (+ message –m possible)
isepse2014% cd ..cd
isep2014% git clone @...
…touch bzg.txt : ajouter un fichier vide / modifier un fichier 
…echo « » > bzg.txt : ajouter « » dans le fichier
…less bzg ? 
     













grep est utilisée pour rechercher une « string » dans un fichier. Ex : grep « toto » filetxt
find est utilisé pour rechercher un objet dans un fichier.    Ex : find . –name « file.txt » ou encore find home/user/ -name « .git »
chmod
globbing : rechercher un élément d’une manière globale en utilisant un raccourci
# !/bin/bash : bash est le nom de l’environnement (executable)
Pour renommer un fichier, il faut : mv file.txt filez.txt, on le déplace « move ».


TP2 : 
Utilisation des lignes de commande : Lié au fait qu’avant les systèmes ne gérait pas les interfaces graphiques avant. Maintenant, certains les utilisent toujours plutôt que la souris. Les lignes de commandes sont du texte. Ce texte peut être stocké quelque part et réutilisé. Lorsqu’on communique avec un ordinateur sous forme de texte on peut structurer notre langage, on aura toute la puissance d’un langage de programmation.
2 grandes familles : Langage compilé comme le java. Le compilateur fait passer me programme de son état de fichier texte à un exécutable par la machine.
	Langage interprété au fur et à mesure ligne par ligne. Exécute directement la ligne du programme. Read Eval Print Loop (REPL). Bash est un interpréteur (ls : ligne de code dans un langage de programmation).
Shell considéré comme DSL : Domain Specific Language : Outil spécialisé. Permet d’intéragir avec le système d’exploitation et notamment sur ce qu’il y a sur la machine et les programmes.
Nom de fichier : Ce qui va caractériser un fichier c’est un chemin absolu pour y accéder partant de la racine. Lorsque l’on exécute un programme sous Shell on tape seulement ce qui correspond au nom du fichier mais Bash doit pouvoir savoir dans quel répertoire se trouve ce programme. On va pouvoir changer la liste des endroits où on va mettre les fichiers et où on va venir les chercher. PATH est la variable qui contient les chemins des programmes exécutables.  Les noms de variables sont en majuscule. 
On accède au contenu d’une variable d’environnement avec $ puis le nom de la variable, ici PATH.
Ce qu’on veut c’est accéder le contenu d’une variable d’environnement dont le nom est PATH. $PATH donne « commande introuvable ».  Bash s’attend à trouver une commande et si on met l’accès au contenu d’une variable, il va regarder ce contenu et s’attendre que ce soit ça la commande.
Il remplace donc $PATH par le contenu de la variable PATH. On ne lui a pas demandé d’afficher le contenu de la variable, on lui a demandé d’exécuter le contenu de la variable. 
La commande la plus simple pour afficher une variable va être « echo ».
Chaque variable est associée non seulement à une valeur mais aussi à un type (nombre à virgule par exemple). 
Bash ne traite quasiment que des chaînes de caractères. PATH contient un ensemble de chaînes de caractères qui décrivent des répertoires. 
On sépare les chaînes de caractères par « : ». 
Bash et le Shell sont particulièrement adaptés pour traiter des fichiers qui contiennent du texte. La notion de séparateur intervient alors pour mettre en forme ce texte. Un texte contient des lignes et on aura la notion de champs dans les lignes. 

Commandes : 
Copier : cp
Lister : ls
éditeur de texte <> traitement de texte : modifier du texte brut <> rajoute la gestion de mise en page 
ex : gedit, editor
EDITOR : variable d’environnement qui gère l’éditeur
Bash est l’un des shell existants sous Linux, l’un des plus répandus. 
Pour savoir sous quel shell on est, il faut utiliser la variable d’env. SHELL et pour voir rapidement le contenu de la variable on utilise : echo $SHELL. 
etc/passwd : contient toutes les informations de connexion des utilisateurs
cat : éditeur de texte (tout comme nano)
Si on souhaite éditer un fichier, on doit mettre le nom de l’éditeur de texte avant la commande. Ici donc cat etc/passwd.
Sous bash on a ce qu’on appelle la complétion automatique, on peut donc appuyer sur la tabulation pour compléter un élément que l’on est en train de traiter.
man : commande qui va afficher la documentation d’une commande. Ex : man/false. 
Le shell bin/false est associé à tout type d’utilisateur afin qu’ils n’aient pas accès à un shell.
Rechercher tous les shell utiliser dans /etc/passwd : 
- Prendre la liste des shell avec tous les doublons : prendre le contenu de /etc/passwd et prendre le contenu de ce qui est écrit après les « : ». Sélectionner les derniers champs du fichier : utilisation de la commande unix « cut » : cut permet de récupérer des champs dans des lignes : ici cut –d : -f7 /etc/passwd
Le résultat de l’exécution d’une commande peut être mis dans un fichier. Cela se fait sous la forme d’une redirection de la sortie standard (flux de texte sortant, s’affichant sur le terminal) à l’intérieur d’un fichier. Cela s’effectue avec le symbole « > ». ex : cut -d: -f7 /etc/passwd > allShells.txt. si le fichier n’existe pas, il sera créé dans le répertoire courant.
- Trier : commande « sort ». On insère les résultats dans un autre fichier. 
Commande globale : sort allShells.txt > allShellsSorted.txt
Pour compter le nombre de doublons : uniq –c allShellsSorted.txt
Supprimer les doublons : uniq : permet de supprimer les doublons.
- Par ordre numérique décroissant : sort –nr allShellsSortedUniq.txt. –n permet de trier par ordre numérique croissant et on rajoute r (-r tout seul) 	après –n pour avoir un ordre décroissant numérique
Il faudrait brancher la sortie standard d’une commande sur l’entrée standard de la commande précédente afin de ne pas avoir tous ces fichiers. 
Pour effectuer le programme en une seule ligne : cut -f7 -d : /etc/passwd |sort|uniq -c| sort -nr
Une autre façon de rediriger la sortie standard est de remplacer le contenu du fichier soit d’écrire à la suite en utilisant overwrite et append. 
Les traces de requêtes sont stockées dans des fichiers de log.
pwd : permet de print le working directory. $PWD : contient le directory. 
Faire un programme qui lise un fichier texte et calcule le nombre d’occurrence des différents mots, trie puis affiche les mots à partir de  http://www.gutenberg.org/cache/epub/45495/pg45495.txt
(on utilise http://algs4.cs.princeton.edu/63suffix/mobydick.txt)
- Récupérer le texte avec « wget » puis l’adresse ou au lieu d’enregistrer le fichier on peut directement travailler sur la sortie standard en ne téléchargeant pas le fichier 
- passer d’un texte à un ensemble de mot en supprimant les séparateurs, apostrophes, etc. en les transformant en espace à la place avec la commande « tr » pour translate
- transformer le texte avec un mot par ligne 
- trouver le nombre d’occurrence de chaque mot
- trier
Pour l’instant on a donc : wget http://www.gutenberg.org/cache/epub/45495/pg45495.txt | tr -s -c [:alpha:] ‘\n’
-s : remplacer un élément par un autre
-c : les éléments qui devront être remplacés ce qui ne sont pas 
-[:alpha:] : caractères alphabétiques
-‘\n’ : retour à la ligne
Puis on ajoute | tr « A-Z » « a-z »
==> on indique un « range »
Version finale cat mobydick.txt | tr –s –c [:alpha:] ‘\n’ | tr  -s “A-Z” “a-z” | sort | uniq –c | sort –nr | head. 
==> Cat : affiche le fichier à traiter
==> Head : permet d’afficher seulement les 10 premiers.
Si l’on est bloqué à un moment on peut faire “CTRL + D” afin de signaler la fin du traitement du fichier. 
En termes de performance, tout ce travail est très bon. 
history > cmds.txt permet de mettre l’historique des commandes entrées sur le terminal depuis le début et ce dans un fichier texte cmds.txt. 
